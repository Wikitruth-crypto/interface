import{bm as e,r as t,ae as r,i as n}from"./vendor-BDtTUao2.js";import{u as a,k as i,b as o,n as s}from"./index-DzM9oNjl.js";import{u as c}from"./hooks-CTGY0WO4.js";var u=(e=>(e[e.VIEW=0]="VIEW",e[e.TRANSFER=1]="TRANSFER",e[e.APPROVE=2]="APPROVE",e))(u||{});const l=(n,a)=>{const{signTypedDataAsync:i}=e(),[o,s]=t.useState(!1),[c,l]=t.useState(null),[d,m]=t.useState(null),g=(e,t)=>{if(!r(e))throw new Error(`The ${t} address format is invalid: ${e}`)};return{signPermit:t.useCallback(async e=>{const{spender:t,amount:r,label:o,contractAddress:c,domainName:d,domainVersion:f,customDeadline:w}=e;l(null),s(!0);try{if(!a||!n)throw new Error("Please connect your wallet first");if(g(c,"token"),g(t,"spender"),!d)throw new Error("The domain name is not valid");const e="bigint"==typeof r?r:BigInt(r);if(Number(e)<0)throw new Error("The amount cannot be negative");if(!Object.values(u).includes(o))throw new Error(`The permit type is invalid: ${o}`);if(o===u.VIEW&&0!==Number(e))throw new Error("The amount of VIEW type must be 0");const s=w||Math.floor(Date.now()/1e3)+3600,l=((e,t,r,n)=>({name:r,version:n||"1",chainId:e,verifyingContract:t}))(n,c,d,f),y={EIP712Permit:[{name:"label",type:"uint8"},{name:"owner",type:"address"},{name:"spender",type:"address"},{name:"amount",type:"uint256"},{name:"deadline",type:"uint256"}]},p={label:o,owner:a,spender:t,amount:e,deadline:BigInt(s)};0;0;const b=(e=>{const t=e.slice(2);return{r:"0x"+t.slice(0,64),s:"0x"+t.slice(64,128),v:parseInt(t.slice(128,130),16)}})(await i({domain:l,types:y,primaryType:"EIP712Permit",message:p})),E={label:o,owner:a,spender:t,amount:e.toString(),deadline:s,signature:b};return m(E),E}catch(y){const e=y instanceof Error?y:new Error("Failed to generate EIP712 signature");return l(e),null}finally{s(!1)}},[n,a,i]),isLoading:o,error:c,permit:d,reset:t.useCallback(()=>{l(null),m(null),s(!1)},[])}},d=()=>{const{address:e,chainId:r}=a(),{signPermit:n,isLoading:o,error:s}=l(r??0,e??""),u=c(),d=i(e=>e.getEip712Permit),m=i(e=>e.setEip712Permit),[g,f]=t.useState(!1),[w,y]=t.useState(null),p=t.useCallback(e=>{if(!e.deadline)return!0;return Math.floor(Date.now()/1e3)>=e.deadline},[]),b=e=>"signature"in e&&"deadline"in e,E=t.useCallback((e,t)=>{if(b(e)&&!p(e))return null;let r;r=b(e)?(null==t?void 0:t.contractAddress)||"":e.contractAddress;const n=u.find(e=>e.address.toLowerCase()===r.toLowerCase());if(!n)throw new Error("Token metadata not found");const a=n.domainName;if(!a)throw new Error("Token domain name not found");let i,o,s,c,l;if(b(e))i=e.label,o=e.spender,s="bigint"==typeof e.amount||"string"==typeof e.amount?e.amount:BigInt(e.amount),c=null==t?void 0:t.domainVersion,l=null==t?void 0:t.customDeadline;else{const r=e;i=r.label,o=r.spender,s="number"==typeof r.amount?BigInt(r.amount):r.amount,c=r.domainVersion||(null==t?void 0:t.domainVersion),l=r.customDeadline||(null==t?void 0:t.customDeadline)}if(!o)throw new Error("Missing spender parameter");if(!r)throw new Error("Missing contractAddress parameter");return{label:i,spender:o,amount:s,contractAddress:r,domainName:a,domainVersion:c,customDeadline:l}},[p]),h=t.useCallback(async e=>{try{const t=E(e);if(!t)throw new Error("Failed to parse permit params");const r=await n(t);if(!r)throw new Error("Failed to generate signature");return m(e.label,e.spender,e.contractAddress,r),r}catch(t){const e=t instanceof Error?t:new Error("Failed to generate EIP712 signature");throw y(e),e}},[e,r,n,m,E]),I=t.useCallback((e,t,r)=>{const n=d(e,t,r);return n&&!p(n)&&n.label===e&&n.spender===t?n:null},[d,p]);return{getValidPermit:t.useCallback(async(e,t)=>{y(null),f(!0);try{if(b(e)&&!p(e))return e;const r=E(e,t);if(!r){if(b(e))return e;throw new Error("Unexpected error: failed to parse permit params")}const{label:n,spender:a,contractAddress:i}=r,o=I(n,a,i);if(o)return o;return await h(r)}catch(r){const e=r instanceof Error?r:new Error("Failed to get valid permit");throw y(e),e}finally{f(!1)}},[e,r,p,E,d,h]),isExpired:p,signAndSavePermit:h,getCurrentEip712Permit:I,isLoading:g||o,error:w||s}};function m(){const e=n(),{publicClient:r,chainId:i}=a(),c=t.useRef(r);c.current=r;return{readContractERC20:t.useCallback(async(t,n,a,u,l=!1)=>{let d=c.current||r;if(!d){const e=3e3,t=Date.now();for(;!d&&Date.now()-t<e;)await new Promise(e=>setTimeout(e,50)),d=c.current||r}if(!d)throw new Error("Public client not available. Please ensure WagmiProvider is properly configured.");let m="erc20"===t?o.OFFICIAL_TOKEN:o.ERC20_SECRET;const g=s(m,i);let f=[],w={};u&&u.length>0?(f=[t,n,a,u,i],w={address:n,abi:g.abi,functionName:a,args:u}):(f=[t,n,a,i],w={address:n,abi:g.abi,functionName:a});if(l){const t=e.getQueryState(f);if(null==t?void 0:t.dataUpdatedAt){if(Date.now()-t.dataUpdatedAt<15e3)return t.data}e.removeQueries({queryKey:f})}else{const t=e.getQueryData(f);if(t)return t}const y=await d.readContract(w);return e.setQueryData(f,y),y},[i,e])}}function g(){const{readContractERC20:e}=m();return{allowance:async(t,r,n,a=!1)=>{try{const i=await e("erc20",t,"allowance",[r,n],a);return"bigint"==typeof i?i:"number"==typeof i||"string"==typeof i?BigInt(i):BigInt(0)}catch(i){return BigInt(0)}},balanceOf:async(t,r,n=!1)=>{try{const a=await e("erc20",t,"balanceOf",[r],n);return"bigint"==typeof a?a:"number"==typeof a||"string"==typeof a?BigInt(a):BigInt(0)}catch(a){return BigInt(0)}},decimals:async t=>{try{const r=await e("erc20",t,"decimals",[]);return r?Number(r):0}catch(r){return 0}},name:async t=>{try{const r=await e("erc20",t,"name",[]);return r?String(r):""}catch(r){return""}},symbol:async t=>{try{const r=await e("erc20",t,"symbol",[]);return r?String(r):""}catch(r){return""}},totalSupply:async(t,r=!1)=>{try{const n=await e("erc20",t,"totalSupply",[],r);return"bigint"==typeof n?n:"number"==typeof n||"string"==typeof n?BigInt(n):BigInt(0)}catch(n){return BigInt(0)}},mintDate:async(t,r,n=!1)=>{try{const a=await e("erc20",t,"mintDate",[r],n);return a?Number(a):0}catch(a){return 0}}}}function f(){const{readContractERC20:e}=m();return{underlyingToken:async t=>{try{const r=await e("secret",t,"underlyingToken");return r?String(r):""}catch(r){return""}},balanceOfWithPermit:async(t,r,n=!1)=>{try{const a=await e("secret",t,"balanceOfWithPermit",[r],n);return"bigint"==typeof a?a:"number"==typeof a||"string"==typeof a?BigInt(a):BigInt(0)}catch(a){return BigInt(0)}},allowanceWithPermit:async(t,r,n=!1)=>{try{const a=await e("secret",t,"allowanceWithPermit",[r],n);return"bigint"==typeof a?a:"number"==typeof a||"string"==typeof a?BigInt(a):BigInt(0)}catch(a){return BigInt(0)}},DOMAIN_SEPARATOR:async t=>{try{const r=await e("secret",t,"DOMAIN_SEPARATOR");return r?String(r):""}catch(r){return""}},EIP_PERMIT_TYPEHASH:async t=>{try{const r=await e("secret",t,"EIP_PERMIT_TYPEHASH");return r?String(r):""}catch(r){return""}},isSignatureUsed:async(t,r,n=!1)=>{try{const a=await e("secret",t,"isSignatureUsed",[r],n);return!!a&&Boolean(a)}catch(a){return!1}}}}const w=()=>{const[e,r]=t.useState(!1),[n,a]=t.useState(BigInt(0)),[i,o]=t.useState(!1),{allowance:s}=g(),{allowanceWithPermit:l}=f(),{getValidPermit:m}=d(),w=c();return{readAllowance:async(e,t,n,i,c=!1)=>{r(!0);try{const d=w.find(t=>t.address.toLowerCase()===e.toLowerCase());if(!d)throw new Error("Token metadata not found");let g=BigInt(0);if("ERC20"===d.types)g=await s(e,t,n,c);else{if("Secret"!==d.types)return r(!1),{isEnough:!1,allowanceAmount:BigInt(0)};{const t=await m({spender:n,amount:BigInt(0),label:u.VIEW,contractAddress:e});g=await l(e,t,c)}}const f=g>=(e=>{if("bigint"==typeof e)return e;if("number"==typeof e){if(!Number.isFinite(e)||!Number.isInteger(e))throw new Error("targetAmount must be an integer number");if(!Number.isSafeInteger(e))throw new Error("targetAmount number exceeds safe integer range; pass bigint or integer string");return BigInt(e)}if("string"==typeof e){if(!/^\d+$/.test(e))throw new Error("targetAmount string must be an integer representation");return BigInt(e)}throw new Error("Unsupported targetAmount type")})(i);return o(f),a(g),r(!1),{isEnough:f,allowanceAmount:g}}catch(d){return r(!1),{isEnough:!1,allowanceAmount:BigInt(0)}}},isLoading:e,allowanceAmount:n,isEnough:i}};export{u as P,g as a,f as b,d as c,w as u};
