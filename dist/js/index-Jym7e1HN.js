const e="0x85d526809D03d17b0dBA17372Bae2E156958F260",r=e=>{const r=window.atob(e);return"0x"+Array.from(r,e=>("0"+e.charCodeAt(0).toString(16)).slice(-2)).join("")},t=e=>{var r;const t=(null==(r=(e.startsWith("0x")?e.slice(2):e).match(/.{1,2}/g))?void 0:r.map(e=>String.fromCharCode(parseInt(e,16))).join(""))||"";return window.btoa(t)};class s{static async cryptoKeyToBase64(e){const r=await window.crypto.subtle.exportKey("raw",e),t=String.fromCharCode(...new Uint8Array(r));return btoa(t)}static async base64ToCryptoKey(e,r={name:"AES-GCM"}){const t=atob(e),s=new Uint8Array(t.length);for(let a=0;a<t.length;a++)s[a]=t.charCodeAt(a);return await window.crypto.subtle.importKey("raw",s,r,!0,["encrypt","decrypt"])}static arrayBufferToBase64(e){let r="";const t=new Uint8Array(e),s=t.byteLength;for(let a=0;a<s;a++)r+=String.fromCharCode(t[a]);return window.btoa(r)}static base64ToArrayBuffer(e){const r=window.atob(e),t=r.length,s=new Uint8Array(t);for(let a=0;a<t;a++)s[a]=r.charCodeAt(a);return s.buffer}static async cryptoKeyToBase64_ECDH(e,r){const t=r?"spki":"pkcs8",s=await window.crypto.subtle.exportKey(t,e);return this.arrayBufferToBase64(s)}static async base64ToCryptoKey_ECDH(e,r){const t=this.base64ToArrayBuffer(e),s=r?"spki":"pkcs8",a=r?[]:["deriveKey"];return await window.crypto.subtle.importKey(s,t,{name:"ECDH",namedCurve:"P-256"},!0,a)}static async generateKeyPair(){const{publicKey:e,privateKey:t}=await window.crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"]),s=await this.cryptoKeyToBase64_ECDH(t,!1),a=await this.cryptoKeyToBase64_ECDH(e,!0);return{privateKey_bytes:r(s),publicKey_bytes:r(a)}}static async generateSharedKey(e,s){const a=t(e),n=t(s),c=await this.base64ToCryptoKey_ECDH(a,!0),i=await this.base64ToCryptoKey_ECDH(n,!1),o=await window.crypto.subtle.deriveKey({name:"ECDH",public:c},i,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),y=await this.cryptoKeyToBase64(o);return r(y)}static async encryptBase(e,s){const a=t(s),n=await this.base64ToCryptoKey(a),c=window.crypto.getRandomValues(new Uint8Array(12)),i=(new TextEncoder).encode(e),o=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:c},n,i),y=this.arrayBufferToBase64(c.buffer),d=this.arrayBufferToBase64(o);return{iv_bytes:r(y),encrypted_bytes:r(d)}}static async decryptBase(e,r,s){const a=t(e),n=t(r),c=t(s),i=this.base64ToArrayBuffer(a),o=this.base64ToArrayBuffer(n),y=await this.base64ToCryptoKey(c);if(!y)throw new Error("shareKey is null");const d=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:i},y,o);return(new TextDecoder).decode(d)}}class a{static async encrypt(e,r,t){if(!e||!r||!t)return{success:!1,error:"Missing required parameters: publicKey, privateKey, fileCid, or password is empty"};try{const a=await s.generateSharedKey(e,r);if(!a)return{success:!1,error:"Failed to generate shared key"};const{iv_bytes:n,encrypted_bytes:c}=await s.encryptBase(t,a);return t===await s.decryptBase(n,c,a)?{success:!0,data:{iv_bytes:n,encrypted_bytes:c}}:{success:!1,error:"Encryption verification failed"}}catch(a){return{success:!1,error:a instanceof Error?a.message:"Unknown encryption error"}}}static async encryptList(e,r,t){if(!e||!r||!t)return{success:!1,error:"Missing required parameters"};try{let s=[];for(const a of t){const t=await this.encrypt(e,r,a);if(!t.success||!t.data){return{success:!1,error:t.error||"Encryption failed"}}s.push(t.data)}return{success:!0,data:s}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Unknown encryption error"}}}}class n{static async decrypt(e,r,t,a){if(!(e&&r&&t&&a))return{success:!1,error:"Missing required parameters"};try{const n=await s.generateSharedKey(e,r);if(!n)return{success:!1,error:"Failed to generate shared key"};return{success:!0,data:await s.decryptBase(t,a,n)}}catch(n){return{success:!1,error:n instanceof Error?n.message:"Unknown decryption error"}}}static async decryptList(e,r,t){if(!e||!r||!t)return{success:!1,error:"Missing required parameters"};try{let s=[];for(const a of t){const t=await this.decrypt(e,r,a.iv_bytes,a.encrypted_bytes);if(!t.success||!t.data){return{success:!1,error:t.error||"Decryption failed"}}s.push(t.data)}return{success:!0,data:s}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Unknown decryption error"}}}}const c={generateKeyPair:s.generateKeyPair.bind(s),generateSharedKey:s.generateSharedKey.bind(s),encryptBase:s.encryptBase.bind(s),decryptBase:s.decryptBase.bind(s),encrypt:a.encrypt.bind(a),encryptList:a.encryptList.bind(a),decrypt:n.decrypt.bind(n),decryptList:n.decryptList.bind(n)};export{e as A,c as C,n as D};
