// import { EncryptionDataType, KeyPairType_Mint } from '@dapp/types/typesDapp/metadata/encryption';
import { 
  BoxInfoFormType,
} from '@Create/types/stateType';
import { AllStepOutputs } from '@Create/types/stepType';
import {
  initialMetadataBox,
  MetadataBoxType,
  MintMethodType,
} from '@dapp/types/typesDapp/metadata/metadataBox'; 
import {
  initialMetadataNFT,
  MetadataNFTType,
} from '@dapp/types/typesDapp/metadata/metadataNFT'; 

import {
  initialResultData,
  ResultDataType,
} from '@dapp/types/typesDapp/metadata/resultData';
import { CIDIsExitingType } from '@dapp/types/typesDapp/otherTypes';


export const metadataService = {

  createMetadataBox: async (
    boxInfoForm: BoxInfoFormType,
    allStepOutputs: AllStepOutputs,
    // encryptionData: EncryptionDataType,
    // keyPair: KeyPairType_Mint,
  ) : Promise<MetadataBoxType> => {
    try {
      // Verify required data
      if(allStepOutputs.nftImageCid === '' ) {
        throw new Error('image is empty!');
      }
      if (allStepOutputs.boxImageCid === '') {
        throw new Error('image2 is empty!');
      }
      if(allStepOutputs.fileCidList.length === 0) {
        throw new Error('file is empty!');
      }
      // 
      let publicKey_let = '';
      let fileList_let: string[] = [];
      let encryptionSlicesMetadataCID_let = {
        slicesMetadataCID_encryption: '',
        slicesMetadataCID_iv: '',
      };
      // Verify encryption data
      if(boxInfoForm.mintMethod === 'createAndPublish') {
        
        fileList_let = allStepOutputs.fileCidList;
      } else if(boxInfoForm.mintMethod === 'create') {
        if(allStepOutputs.keyPair.publicKey_minter === '') {
          throw new Error('publicKey_minter is empty!');
        }
        publicKey_let = allStepOutputs.keyPair.publicKey_minter;
        // Verify file chunk count
        if (
          allStepOutputs.encryptionSlicesMetadataCID.slicesMetadataCID_encryption === '' ||
          allStepOutputs.encryptionSlicesMetadataCID.slicesMetadataCID_iv === ''
        ) {
          throw new Error('slicesMetadataCID_encryption is empty!');
        }
        encryptionSlicesMetadataCID_let = allStepOutputs.encryptionSlicesMetadataCID;

        // Verify encryption data for each chunk
        for (let i = 0; i < allStepOutputs.encryptionFileCID.length; i++) {
          if (
            allStepOutputs.encryptionFileCID[i].fileCID_iv === '' || 
            allStepOutputs.encryptionFileCID[i].fileCID_encryption === ''
          ) {
            throw new Error('encryptionFileCID is empty!');
          }
        }

        // Verify password encryption data
        if(
          allStepOutputs.encryptionPasswords.password_iv === '' ||
          allStepOutputs.encryptionPasswords.password_encryption === ''
        ) {
          throw new Error('encryptionData is empty!');
        } 
      } else {
        throw new Error('mintMethod is invalid!');
      }

      // Create MetadataBox object
      const metadataBox: MetadataBoxType = {
        ...initialMetadataBox,
        // BoxInfo Data
        typeOfCrime: boxInfoForm.typeOfCrime,
        label: boxInfoForm.label || [], // Added label property
        title: boxInfoForm.title,
        country: boxInfoForm.country,
        state: boxInfoForm.state,
        description: boxInfoForm.description,
        eventDate: boxInfoForm.eventDate,
        createDate: allStepOutputs.currentTime.createDate,
        timestamp: Number(allStepOutputs.currentTime.timestamp), // Convert to number
        // Image Data
        nftImage: `ipfs://${allStepOutputs.nftImageCid}`,
        boxImage: `ipfs://${allStepOutputs.boxImageCid}`,
        // Mint Method
        mintMethod: boxInfoForm.mintMethod,
        // Encryption Data
        encryptionSlicesMetadataCID: encryptionSlicesMetadataCID_let,
        encryptionFileCID: allStepOutputs.encryptionFileCID,
        encryptionPasswords: allStepOutputs.encryptionPasswords,
        publicKey: publicKey_let,
        // File Data
        fileList: fileList_let,
        // password: '',
      };

      return metadataBox;
    } catch (error) {
      console.error('Create MetadataBox failed:', error);
      throw error;
    }
  },

  createMetadataNFT: async (
    boxInfoForm: BoxInfoFormType,
    allStepOutputs: AllStepOutputs,
  ) : Promise<MetadataNFTType> => {
    try {
      // Verify required data
      if(allStepOutputs.nftImageCid === '' ) {
        throw new Error('image is empty!');
      }

      // Create MetadataNFT object
      const metadataNFT: MetadataNFTType = {
        ...initialMetadataNFT,
        // Basic Info
        tokenId: '', // tokenId generated by contract after mint
        typeOfCrime: boxInfoForm.typeOfCrime,
        title: boxInfoForm.title,
        country: boxInfoForm.country,
        state: boxInfoForm.state,
        // Image
        image: `ipfs://${allStepOutputs.nftImageCid}`,
        eventDate: boxInfoForm.eventDate,
        // Attributes
        // attributes: [
        //   ...initialMetadataNFT.attributes,
        // ]
      };

      return metadataNFT;
    } catch (error) {
      console.error('Create MetadataNFT failed:', error);
      throw error;
    }
  },

  createResultData: (
    mintMethod: MintMethodType,
    fileCidList: string[],
    cidList: CIDIsExitingType[],
    isSuccess: boolean,
    timestamp: string,
  ) => {
    try {
      if (!timestamp) {
        throw (' timestamp is empty!');
      }
      if (fileCidList.length === 0) {
        throw (' fileCidList is empty!');
      }
      if (cidList.length === 0) {
        throw (' cidList is empty!');
      }

      const resultData: ResultDataType = {
        ...initialResultData,
        mintMethod: mintMethod,
        fileCidList: fileCidList,
        timestamp: timestamp,
        isSuccess: isSuccess,
        cidList: cidList.map(cid => cid.cid),
      };
      return resultData;
    } catch (error) {
      console.error('Create Result data JSON failed:', error);
      throw error;
    }
  }


}; 